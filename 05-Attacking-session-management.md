# Attacking session Management
  - it is necessary for giving persistent to the loged in user, so hi did't need to login again & again
  - vulnerability exist in the session management mechanisms largely fall into two categories
	  - **Weakness in the Generation of session tokens**
	  - **WeakNess in the handling of the session tokens throughout their Life Cycle**
  ### Hack Step
   1. application often employ several different items of collectively as TOKEN, including Cookies, URL param, Hidden Form field etc.
   2. Sometime item that appear to be the application's session token may not be, the std session cookie generated by the application ,but not actually used by the application
   3. Observe which new items are passed to the browser after authentication,
   4. To verify which Items are actually being employed as token, find a page that is definitely session-dependent, make several request for it, remove each item one by one and see the effect of response, `compare the respinse with standerd page that contain all the session token or the page that we didnt modify anything`
   
# Alternative to Session
-  not all application employs sessions, some use auth mechanism & complex functionality
## HTTP Authentication
- some application employ authentication form on every page, and browser will submit the form in every request, but this is used rarly, due to complexity of implementation.

## Session State Mechanism
- some application transmit all the data for user to the application instead of using session token, this data will encrypted, like `ViewState` in `ASP.NET`, this will identify each client or user separately for application, like `JWT`
### HACK Step
  1. if HTTP authentication is used then , possibly no session management there
  2. if application use Sessionless State mechanism, but sometimes it difficult to detect with certainty, but following are strong indicators
	  1. Token-like data items issued to client are fairly long `100, more byte`
	  2. application issue new token item in response to every request
	  3. data items appears to be encrypted, or signed as `JWT`
	  4. application reject attempts to submit same item with more than one request
   
# WeakNess in Token Generation
**NOTE:** there are numerous location where an application's security depends on the unpredictability of token it generates,
- example
	- Password recovery tokens sent to the user's registered email address
	- Tokens like CSRF to prevent CSRF attacks
	- Tokens used to gove one-time access to protected resources
	- persistent Token used in `Remember me` function
	- Token allowing customer of a shoping application that does not use authentication to retrieve the current status of an existing order.

## MeaningFUl Tokens
- some session tokens are created using Transformation of the user's username or email, or other information associated with that person,
- this information may be encoded or obfuscated in some way and may be combined with other data,
- eg. `757365723d6461663b6170703d61646d696e3b646174653d30312f31322f3131` by closer looking we knew that this was encoded in `hexadecimal` this can be decoded by decoder. `user=def;app=admin;date=10/10/2021` 
- some components that encountered within structured token
	- Account Username
	- numeric Identifier that application uses to distinguish b/w accounts
	- user's first/last name
	- User's email addr
	- users's group, role etc
	- date/time stamp
	- an incrementing or predictable number
	- Client IP adderess
**NOTE**  not all values of token are processed by the server side, or validated, some of just used, but never processed

## Predictable Tokens
- arise due to
	- Concealed Sequences
	- Time Dependency
	- Weak Random Number generation
## Concealed Sequence
it is common to encounter session token can not be predictable, but when deeply analyse, it may be predictable, by understanding Cryptographi

## Time Dependency
- some application employ algorithms to generate session tokens that use the time of generation as an input to the token's value

## Radndomness of the session token 
- we use burp sequencer
	- find a response from the application that issues the token we want to test, i.e response to login request that issue new `Cookie` containing session token, select `send to sequencer` 

# Encrypted Tokens
- some application use tokens that contain meaningful information about the user , but since token generated need secret key to encrypt the token but since the user didn't know secret, he cant decrypt token and temper with it.
## ECB Ciphers
## CBC Ciphers
## Encrypted Tokens and information
- we use `bitfliper` in intruder payload to temper with encrypted data and analyse if we get find and block that manipute the response
- **NOTE:**
-   Some applications use the technique of encrypting meaningful data within request parameters more generally in an attempt to prevent tampering of data, such as the prices of shopping items. In any location where you see apparently encrypted data that plays a key role in application functionality, you should try the bit-flipping technique to see whether you can manipulate the encrypted information in a meaningful way to interfere with application logic.

# WeakNess in Session TOken handling
- No matter how the random token is there, or not contain any meaningful information, but if it handle session token in Unsafe way , this it makes application to vulnerable to attack several ways

## Disclosure of Tokens on the Network
- probabily send token via HTTP instead HTTPS in some place like static page, unauthentic page etc

## Disclosure of Tokens in Logs
## Vulnerable Session Termination
- session will not expire after logout, or other session are not expire when use password reset etc
- if user log out then just cookie is removed from the browser, but if we replace the cookie session of old one than it automatically re-login the user.

## Client Exposure to TOken Hijacking

### HACK Step
   1. if application issue fresh token to unauthenticated users, obtain token and perform login, and see if application issue new token to the user, if not it is vulnerable to `session Fixation`
   2. identify the format of session token used by the application, modify our token to an invented value that is validly formed, attempt to login, if application allows to create an authenticated session suing invented token, it is vulnerable to `session fixation`

# Liberal Cookie Scope
## Cookie Domain Restrictions

# Securing Session Management
## General Strong TOkens
   - use extremely large set of possible values
   - Contain a strong source of pseudorandomness, 
   - token should consist of nothing more than an identifier user by the server to locate the relevant session object to be used to process the user's request

## Protect Tokens throughout their Life cycle
   - session token should never transmitted through URL it create chance of session fixation
   - Logout Function should be implemented and this should dispose all the session resource
   - session expiration should be implemented after fixed amount of time.
   - concurrent login should be prevented
 ## LOG, Monitor, Alert
 ## Reactive Session Termination 
 - on some critical application functionality like Banking application
